#version 460
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_samplerless_texture_functions : require

#include "./shared.glsl"
#include <camera.glsl>
#include <textures.glsl>

layout(set = 0, binding = 0) uniform sampler gsamplers[];
layout(set = 0, binding = 1) uniform texture2D gtextures[];
layout(set = 1, binding = 0, r32ui) uniform coherent
    restrict uimage2D gstorage[];

layout(scalar, push_constant) uniform PushConstant {
    uint red_img;
    uint green_img;
    uint blue_img;
    vec2 noise_offset;
    CameraBuf camera;
    Rays rays_ptr;
}
pc;

vec4 read_blue_noise(ivec2 loc) {
    vec2 tex_size = vec2(1024);
    ivec2 offset = ivec2(pc.noise_offset * tex_size);
    ivec2 wrappedloc = (loc + offset) % ivec2(tex_size);
    vec4 sampleValue = texelFetch(gtextures[BLUE_TEX], wrappedloc, 0);
    return sampleValue;
}

vec4 project(mat4 world_to_clip, vec3 pos) {
    vec4 screen_pos = world_to_clip * vec4(pos, 1.);
    screen_pos.xyz /= screen_pos.w;
    return screen_pos;
}

bool in_bounds(vec2 pos, vec2 dims) {
    return all(greaterThanEqual(pos, ivec2(0))) && all(lessThan(pos, dims));
}

bool in_clip_space(vec4 pos) {
    return !(pos.w <= 0.0 || pos.x < -1.0 || pos.x > 1.0 || pos.y < -1.0 ||
             pos.y > 1.0);
}

vec2 ndc_to_raster(vec4 ndc, vec2 dims) {
    vec2 res = (ndc.xy * 0.5 + 0.5);
    res.y = 1. - res.y;
    return res * dims;
}

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

void main() {
    uvec2 dims = imageSize(gstorage[pc.red_img]);

    uint idx = gl_GlobalInvocationID.x;
    if (idx > pc.rays_ptr.len) { return; }

    Ray ray = pc.rays_ptr.rays[idx];
    vec3 gray_start = ray.start.xyz;
    vec3 gray_end = ray.end.xyz;
    if (gray_start == vec3(0) && gray_end == vec3(0.)) { return; }

    vec4 cray_start = project(pc.camera.cam.world_to_clip, gray_start);
    vec4 cray_end = project(pc.camera.cam.world_to_clip, gray_end);

    if (!in_clip_space(cray_start) && !in_clip_space(cray_end)) { return; }

    vec2 ray_start = ndc_to_raster(cray_start, dims);
    vec2 ray_end = ndc_to_raster(cray_end, dims);

    vec2 ray_dir = ray_end - ray_start;
    float ray_len = length(ray_dir);
    ray_dir /= ray_len;

    vec4 blue_noise = read_blue_noise(ivec2(idx, 0));

    vec2 start = ray_start;
    vec2 dir = ray_dir;
    float n = 50.;
    float step = ray_len / n;
    step = step + (blue_noise.x * 2. - 1.) * step / 2.;
    step = max(step, sqrt(1.));
    for (float s = 0; s < ray_len; s += step) {
        vec2 p = start + dir * s;
        ivec2 pix = ivec2(p + blue_noise.yz * 2.);
        vec3 col = ray.color.rgb * ray.color.w;
        uvec3 ucol = uvec3(floor(col * 1000.));
        // if (!in_bounds(pix, dims)) { continue; }
        imageAtomicAdd(gstorage[pc.red_img], pix, ucol.r);
        imageAtomicAdd(gstorage[pc.green_img], pix, ucol.g);
        imageAtomicAdd(gstorage[pc.blue_img], pix, ucol.b);
    }
}

void dda(vec2 ray_start, vec2 ray_dir, float ray_len_squared, vec2 dims) {
    ivec2 map_pos = ivec2(floor(ray_start + 0.));

    vec2 delta_dist = 1.0 / abs(ray_dir);
    ivec2 ray_step = ivec2(sign(ray_dir));
    vec2 side_dist = (sign(ray_dir) * (vec2(map_pos) - ray_start) +
                      (sign(ray_dir) * 0.5) + 0.5) *
                     delta_dist;

    for (int i = 0; i < 2500; i++) {
        vec2 len = ray_start - map_pos;
        if (dot(len, len) > ray_len_squared) { break; }

        bvec2 mask = lessThanEqual(side_dist.xy, side_dist.yx);
        side_dist += vec2(mask) * delta_dist;
        map_pos += ivec2(vec2(mask)) * ray_step;
        if (!in_bounds(map_pos, dims)) { continue; }

        imageAtomicAdd(gstorage[pc.red_img], map_pos.xy, 200u);
        imageAtomicAdd(gstorage[pc.green_img], map_pos.xy, 10u);
        imageAtomicAdd(gstorage[pc.blue_img], map_pos.xy, 25u);
    }
}
