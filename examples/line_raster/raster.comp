#version 460
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_scalar_block_layout : require

#include "./shared.glsl"
#include <camera.glsl>

layout(set = 0, binding = 0, r32ui) uniform coherent
    restrict uimage2D gtextures[];

layout(std430, push_constant) uniform PushConstant {
    uint red_img;
    uint green_img;
    uint blue_img;
    CameraBuf camera;
    Rays rays_ptr;
}
pc;

vec4 project(vec3 pos) {
    vec4 screen_pos = pc.camera.cam.world_to_clip * vec4(pos, 1.);
    screen_pos.xyz /= screen_pos.w;
    return screen_pos;
}

bool in_bounds(vec2 pos, vec2 dims) {
    return all(greaterThanEqual(pos, ivec2(0))) && all(lessThan(pos, dims));
}

bool in_clip_space(vec4 pos) {
    return !(pos.w <= 0.0 || pos.x < -1.0 || pos.x > 1.0 || pos.y < -1.0 ||
             pos.y > 1.0);
}

vec2 get_uv_comp(uvec3 global_id, vec2 tex_size) {
    return (vec2(global_id) + 0.5) / vec2(tex_size);
}

vec2 ndc_to_raster(vec4 ndc, vec2 dims) {
    vec2 res = (ndc.xy * 0.5 + 0.5);
    res.y = 1. - res.y;
    return res * dims;
}

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

void main() {
    uvec2 dims = imageSize(gtextures[pc.red_img]);

    uint idx = gl_GlobalInvocationID.x;
    if (idx > pc.rays_ptr.len) { return; }

    Ray ray = pc.rays_ptr.rays[idx];
    vec3 gray_start = ray.start.xyz;
    vec3 gray_end = ray.end.xyz;
    if (gray_start == vec3(0) && gray_end == vec3(0.)) { return; }

    vec4 cray_start = project(gray_start);
    vec4 cray_end = project(gray_end);

    if (!in_clip_space(cray_start) && !in_clip_space(cray_end)) { return; }

    vec2 ray_start = ndc_to_raster(cray_start, dims);
    vec2 ray_end = ndc_to_raster(cray_end, dims);

    vec2 ray_dir = ray_end - ray_start;
    float ray_len_squared = dot(ray_dir, ray_dir);
    ray_dir /= sqrt(ray_len_squared);

    vec2 start = ray_start;
    vec2 dir = ray_dir;
    float rlength = sqrt(ray_len_squared);
    float n = 250.;
    float step = rlength / n;
    step = max(step, sqrt(2.));
    for (float s = 0; s < rlength; s += step) {
        vec2 p = start + dir * s;
        ivec2 pix = ivec2(p + 0.);
        vec3 col = ray.color.rgb * ray.color.w;
        uvec3 ucol = uvec3(floor(col * 25.));
        // if (!in_bounds(pix, dims)) { continue; }
        imageAtomicAdd(gtextures[pc.red_img], pix, ucol.r);
        imageAtomicAdd(gtextures[pc.green_img], pix, ucol.g);
        imageAtomicAdd(gtextures[pc.blue_img], pix, ucol.b);
    }
}

void dda(vec2 ray_start, vec2 ray_dir, float ray_len_squared, vec2 dims) {
    ivec2 map_pos = ivec2(floor(ray_start + 0.));

    vec2 delta_dist = 1.0 / abs(ray_dir);
    ivec2 ray_step = ivec2(sign(ray_dir));
    vec2 side_dist = (sign(ray_dir) * (vec2(map_pos) - ray_start) +
                      (sign(ray_dir) * 0.5) + 0.5) *
                     delta_dist;

    for (int i = 0; i < 2500; i++) {
        vec2 len = ray_start - map_pos;
        if (dot(len, len) > ray_len_squared) { break; }

        bvec2 mask = lessThanEqual(side_dist.xy, side_dist.yx);
        side_dist += vec2(mask) * delta_dist;
        map_pos += ivec2(vec2(mask)) * ray_step;
        if (!in_bounds(map_pos, dims)) { continue; }

        imageAtomicAdd(gtextures[pc.red_img], map_pos.xy, 200u);
        imageAtomicAdd(gtextures[pc.green_img], map_pos.xy, 10u);
        imageAtomicAdd(gtextures[pc.blue_img], map_pos.xy, 25u);
    }
}
