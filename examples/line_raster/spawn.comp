#version 460
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_scalar_block_layout : require

#include "shared.glsl"

layout(std430, push_constant) uniform PushConstant {
    uint num_rays;
    uint num_bounces;
    float time;
    Rays rays_ptr;
    Lights lights_ptr;
}
pc;

const float PI = acos(-1.);

float hash11(float p) {
    p = fract(p * .1031);
    p *= p + 33.33;
    p *= p + p;
    return fract(p);
}

vec3 hash13(float p) {
    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.xxy + p3.yzz) * p3.zyx);
}

vec3 rand_cone_direction(const float i, const float angularRadius,
                         const int steps) {
    float x = i * 2.0 - 1.0;
    float y = i * float(steps) * 16.0 * 16.0 * goldenAngle;

    float angle = acos(x) * radians(angularRadius) * 1. / PI;
    float c = cos(angle);
    float s = sin(angle);

    return vec3(cos(y) * s, sin(y) * s, c);
}

mat2 rot(float a) {
    float c = cos(a), s = sin(a);
    return mat2(c, -s, s, c);
}

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx == 0) { pc.rays_ptr.len = pc.num_rays * pc.num_bounces; }
    if (idx > pc.num_rays * pc.num_bounces) { return; }
    uint ray_idx = idx * pc.num_bounces;
    for (int i = 0; i < pc.num_bounces; ++i) {
        pc.rays_ptr.rays[ray_idx + i] = Ray(vec4(0.), vec3(0.), vec3(0.));
    }

    uint light_idx = uint(floor(hash11(idx) * pc.lights_ptr.len));
    // light_idx = 0;

    Light light = pc.lights_ptr.lights[light_idx];
    vec3 col = light.color.rgb;
    vec3 origin = (light.transform * vec4(vec3(0., 0., 0.), 1.)).xyz;
    origin = light.pos.xyz;
    vec3 dir = rand_cone_direction(float(idx) / float(pc.num_rays), 6.,
                                   int(pc.num_rays));
    // dir = vec3(0., 0., 1.);
    dir = (light.transform * vec4(dir, 0.)).xyz;
    // dir = (vec4(-dir, 0.) * light.transform).xyz;
    dir = normalize(dir);
    // origin.xz *= rot(pc.time);

    for (int i = 0; i < pc.num_bounces; ++i) {
        vec2 hit = trace(origin, dir);
        // if (hit.y <= 0.) { break; }
        if (hit.y <= 0.) { hit.x = 5.; }
        vec3 pos = origin + dir * hit.x;
        vec3 nor = get_norm(pos);

        dir = reflect(dir, nor);
        vec3 end = pos + nor * 0.01;
        float throughput = 1. - float(i) / float(pc.num_bounces);
        if (hit.y <= 0.) { throughput = 0.5; }
        Ray ray = Ray(vec4(col, pow(throughput, 5.)), vec3(origin), vec3(end));
        pc.rays_ptr.rays[ray_idx + i] = ray;
        if (hit.y <= 0.) { break; }

        origin = end;
    }
}
